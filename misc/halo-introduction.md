# Halo æ­£å¼å¼€æº: ä½¿ç”¨å¯ç©¿æˆ´è®¾å¤‡è¿›è¡Œå¼€æºå¥åº·è¿½è¸ª

![](https://files.mdnice.com/user/38198/845ff80c-01e6-40a5-80df-55e308933dd0.jpg)

åœ¨é£žé€Ÿå‘å±•çš„å¯ç©¿æˆ´æŠ€æœ¯é¢†åŸŸï¼Œæˆ‘ä»¬æ­£å¤„äºŽä¸€ä¸ªåå­—è·¯å£ã€‚å¸‚åœºä¸Šå……æ–¥ç€å„å¼æ—¶å°šã€åŠŸèƒ½ä¸°å¯Œçš„è®¾å¤‡ï¼Œå£°ç§°èƒ½å¤Ÿå½»åº•æ”¹å˜æˆ‘ä»¬å¯¹å¥åº·å’Œå¥èº«çš„æ–¹å¼ã€‚ç„¶è€Œï¼Œåœ¨è¿™äº›å…‰é²œçš„å¤–è§‚å’Œè¥é”€å®£ä¼ èƒŒåŽï¼Œéšè—ç€ä¸€ä¸ªä»¤äººæ‹…å¿§çš„çŽ°å®žï¼šå¤§å¤šæ•°è¿™äº›è®¾å¤‡æ˜¯å°é—­ç³»ç»Ÿï¼Œå…¶å†…éƒ¨è¿è¡Œè¢«ä¸“æœ‰ä»£ç å’Œå°é—­ç¡¬ä»¶æ‰€æŽ©ç›–ã€‚ä½œä¸ºæ¶ˆè´¹è€…ï¼Œæˆ‘ä»¬å¯¹è¿™äº›è®¾å¤‡å¦‚ä½•æ”¶é›†ã€å¤„ç†åŠå¯èƒ½å…±äº«æˆ‘ä»¬çš„å¥åº·æ•°æ®ä¸€æ— æ‰€çŸ¥ã€‚

è¿™æ—¶ï¼Œ**Halo** å‡ºçŽ°äº†ï¼Œå®ƒæ˜¯ä¸€ç§æ—¨åœ¨è®©å¥åº·è¿½è¸ªæ›´åŠ æ™®æƒ åŒ–çš„å¼€æºæ›¿ä»£æ–¹æ¡ˆã€‚é€šè¿‡è¿™ç³»åˆ—æ–‡ç« ï¼Œæˆ‘ä»¬å°†å¼•å¯¼ä½ ä»ŽåŸºç¡€å…¥æ‰‹ï¼Œæž„å»ºå¹¶ä½¿ç”¨å®Œå…¨é€æ˜Žã€å¯å®šåˆ¶çš„å¯ç©¿æˆ´è®¾å¤‡ã€‚

éœ€è¦è¯´æ˜Žçš„æ˜¯ï¼ŒHalo çš„ç›®æ ‡å¹¶ä¸æ˜¯åœ¨æŠ›å…‰åº¦æˆ–åŠŸèƒ½å®Œæ•´æ€§ä¸Šä¸Žæ¶ˆè´¹çº§å¯ç©¿æˆ´è®¾å¤‡ç«žäº‰ã€‚ç›¸åï¼Œå®ƒæä¾›äº†ä¸€ç§ç‹¬ç‰¹çš„ã€åŠ¨æ‰‹å®žè·µçš„æ–¹å¼æ¥ç†è§£å¥åº·è¿½è¸ªè®¾å¤‡èƒŒåŽçš„æŠ€æœ¯ã€‚

æˆ‘ä»¬å°†ä½¿ç”¨ `Swift 5` æ¥æž„å»ºå¯¹åº”çš„ iOS ç•Œé¢ï¼Œä»¥åŠ `Python >= 3.10`ã€‚ç”±äºŽæ­¤é¡¹ç›®çš„ä»£ç å®Œå…¨ [å¼€æº](https://github.com/cyrilzakka/Halo-iOS)ï¼Œä½ å¯ä»¥éšæ—¶æäº¤åˆå¹¶è¯·æ±‚ï¼Œæˆ–è€…åˆ†å‰é¡¹ç›®ä»¥æŽ¢ç´¢å…¨æ–°çš„æ–¹å‘ã€‚

**ä½ å°†éœ€è¦ï¼š**

- èŽ·å– [COLMI R02](https://www.aliexpress.us/item/3256806445134241.html?gatewayAdapt=glo2usa4itemAdapt) å®žé™…è®¾å¤‡ï¼Œä»·æ ¼åœ¨æ’°å†™æ—¶ä¸º 11 åˆ° 30 ç¾Žé‡‘å·¦å³ã€‚
- ä¸€ä¸ªå®‰è£…äº† Xcode 16 çš„å¼€å‘çŽ¯å¢ƒï¼Œä»¥åŠå¯é€‰çš„ Apple å¼€å‘è€…è®¡åˆ’ä¼šå‘˜èµ„æ ¼ã€‚
- `Python >= 3.10`ï¼Œå¹¶å®‰è£…äº† `pandas`ã€`numpy`ã€`torch` å½“ç„¶è¿˜æœ‰ `transformers`ã€‚

**è‡´è°¢**

æ­¤é¡¹ç›®åŸºäºŽ [Python ä»“åº“](https://tahnok.github.io/colmi_r02_client/) çš„ä»£ç åŠæˆ‘çš„å­¦ä¹ æˆæžœæž„å»ºã€‚

**å…è´£å£°æ˜Ž**

ä½œä¸ºä¸€ååŒ»ç”Ÿï¼Œæˆ‘æœ‰æ³•å¾‹ä¹‰åŠ¡æé†’ä½ ï¼šä½ å³å°†é˜…è¯»çš„å†…å®¹å¹¶ä¸æ˜¯åŒ»å­¦å»ºè®®ã€‚çŽ°åœ¨ï¼Œè®©æˆ‘ä»¬å¼€å§‹è®©ä¸€äº›å¯ç©¿æˆ´è®¾å¤‡å‘å‡ºèœ‚é¸£å£°å§ï¼

### é…å¯¹æˆ’æŒ‡

åœ¨è¿›å…¥ä»£ç ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å…ˆäº†è§£è“ç‰™ä½Žèƒ½è€—ï¼ˆBLEï¼‰çš„å…³é”®è§„æ ¼ã€‚BLE åŸºäºŽä¸€ä¸ªç®€å•çš„å®¢æˆ·ç«¯-æœåŠ¡å™¨æ¨¡åž‹ï¼Œä½¿ç”¨ä¸‰ä¸ªæ ¸å¿ƒæ¦‚å¿µï¼š_ä¸­å¤®è®¾å¤‡ï¼ˆCentralsï¼‰_ã€_æœåŠ¡ï¼ˆServicesï¼‰_ å’Œ _ç‰¹å¾ï¼ˆCharacteristicsï¼‰_ã€‚ä»¥ä¸‹æ˜¯å®ƒä»¬çš„å…·ä½“ä»‹ç»ï¼š

- **ä¸­å¤®è®¾å¤‡**ï¼ˆä¾‹å¦‚ä½ çš„ iPhoneï¼‰è´Ÿè´£å¯åŠ¨å’Œç®¡ç†ä¸Ž**å¤–è®¾**ï¼ˆä¾‹å¦‚æˆ‘ä»¬çš„ COLMI R02 æˆ’æŒ‡ï¼‰çš„è¿žæŽ¥ã€‚æˆ’æŒ‡é€šè¿‡å¹¿æ’­è‡ªèº«ä¿¡æ¯ç­‰å¾…æ‰‹æœºè¿žæŽ¥ï¼Œæ¯æ¬¡ä»…æ”¯æŒä¸€å°æ‰‹æœºè¿žæŽ¥ã€‚
- **æœåŠ¡**æ˜¯æˆ’æŒ‡ä¸Šç›¸å…³åŠŸèƒ½çš„é›†åˆï¼Œä¾‹å¦‚å¿ƒçŽ‡ç›‘æµ‹æœåŠ¡æˆ–ç”µæ± çŠ¶æ€æœåŠ¡ã€‚æ¯ä¸ªæœåŠ¡éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€æ ‡è¯†ç¬¦ï¼ˆUUIDï¼‰ï¼Œå®¢æˆ·ç«¯é€šè¿‡å®ƒæ¥æ‰¾åˆ°å¯¹åº”æœåŠ¡ã€‚
- **ç‰¹å¾**æ˜¯æ¯ä¸ªæœåŠ¡ä¸­çš„å…·ä½“æ•°æ®ç‚¹æˆ–æŽ§åˆ¶æœºåˆ¶ã€‚ä¾‹å¦‚ï¼Œå®ƒä»¬å¯èƒ½æ˜¯åªè¯»ï¼ˆèŽ·å–ä¼ æ„Ÿå™¨æ•°æ®ï¼‰ã€åªå†™ï¼ˆå‘é€å‘½ä»¤ï¼‰æˆ–ä¸¤è€…å…¼æœ‰ã€‚æœ‰äº›ç‰¹å¾è¿˜èƒ½åœ¨å…¶å€¼å‘ç”Ÿå˜åŒ–æ—¶è‡ªåŠ¨é€šçŸ¥æ‰‹æœºï¼Œè¿™å¯¹äºŽå®žæ—¶å¥åº·ç›‘æµ‹å°¤ä¸ºé‡è¦ã€‚

å½“æ‰‹æœºè¿žæŽ¥åˆ°æˆ’æŒ‡æ—¶ï¼Œä¼šå®šä½æ‰€éœ€çš„æœåŠ¡ï¼Œå¹¶ä¸Žç‰¹å®šç‰¹å¾äº¤äº’ä»¥å‘é€å‘½ä»¤æˆ–æŽ¥æ”¶æ•°æ®ã€‚è¿™ç§ç»“æž„åŒ–çš„æ–¹æ³•ä¸ä»…ç¡®ä¿äº†é€šä¿¡æ•ˆçŽ‡ï¼Œè¿˜èƒ½å»¶é•¿ç”µæ± ä½¿ç”¨æ—¶é—´ã€‚äº†è§£äº†è¿™äº›åŸºç¡€çŸ¥è¯†åŽï¼Œè®©æˆ‘ä»¬å¼€å§‹æž„å»ºå§ï¼

### è®¾ç½® Xcode é¡¹ç›®

åˆ›å»ºä¸€ä¸ªåä¸º `Halo` çš„æ–°é¡¹ç›®ï¼Œç›®æ ‡å¹³å°ä¸º `iOS`ã€‚ç»„ç»‡æ ‡è¯†ç¬¦å»ºè®®ä½¿ç”¨åå‘åŸŸåæ ¼å¼ï¼ˆå¦‚ `com.example`ï¼‰ã€‚æœ¬é¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ `com.FirstNameLastName`ã€‚

æŽ¥ä¸‹æ¥ï¼Œä¸ºåº”ç”¨å¯ç”¨å¿…è¦çš„åŠŸèƒ½ã€‚åœ¨ Xcode ä¸­ï¼Œæ‰“å¼€ `Signing & Capabilities` é€‰é¡¹å¡ï¼Œå¯ç”¨ä»¥ä¸‹ **åŽå°æ¨¡å¼ï¼ˆBackground Modesï¼‰**ï¼Œä»¥ç¡®ä¿åº”ç”¨åœ¨åŽå°è¿è¡Œæ—¶èƒ½å¤Ÿä¿æŒä¸Žæˆ’æŒ‡çš„è¿žæŽ¥å¹¶å¤„ç†æ•°æ®ã€‚

ç„¶åŽï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ Apple æä¾›çš„æœ€æ–°æ¡†æž¶ [`AccessorySetupKit`](https://developer.apple.com/documentation/accessorysetupkit/)ï¼Œç”¨äºŽå°†è“ç‰™å’Œ Wi-Fi é…ä»¶è¿žæŽ¥åˆ° iOS åº”ç”¨ã€‚æ­¤æ¡†æž¶è‡ª iOS 18 æŽ¨å‡ºï¼Œæ›¿ä»£äº†ä¼ ç»Ÿçš„å¹¿æ³›è“ç‰™æƒé™è¯·æ±‚æ–¹å¼ï¼Œä¸“æ³¨äºŽä¸ºç”¨æˆ·æ˜Žç¡®æ‰¹å‡†çš„ç‰¹å®šè®¾å¤‡æä¾›è®¿é—®æƒé™ã€‚

å½“ç”¨æˆ·å°è¯•å°† COLMI R02 æˆ’æŒ‡è¿žæŽ¥åˆ°åº”ç”¨æ—¶ï¼Œ`AccessorySetupKit` ä¼šæ˜¾ç¤ºä¸€ä¸ªç³»ç»Ÿç•Œé¢ï¼Œä»…åˆ—å‡ºå…¼å®¹çš„é™„è¿‘è®¾å¤‡ã€‚ç”¨æˆ·é€‰æ‹©è®¾å¤‡åŽï¼Œåº”ç”¨å³å¯ä¸Žæˆ’æŒ‡é€šä¿¡ï¼Œè€Œæ— éœ€è¯·æ±‚å®Œæ•´çš„è“ç‰™æƒé™ã€‚è¿™å¤§å¤§æå‡äº†ç”¨æˆ·éšç§ï¼ŒåŒæ—¶ç®€åŒ–äº†è®¾å¤‡è¿žæŽ¥çš„ç®¡ç†æµç¨‹ã€‚

æ‰“å¼€ `Info.plist` æ–‡ä»¶ï¼ˆå¯ä»¥åœ¨å·¦ä¾§è¾¹æ ä¸­æ‰¾åˆ°ï¼Œæˆ–é€šè¿‡ `Project Navigator (âŒ˜1) > Your Target > Info` å®šä½ï¼‰ã€‚æ·»åŠ ä»¥ä¸‹é”®å€¼æ¡ç›®ä»¥æ”¯æŒä¸Ž COLMI R02 æˆ’æŒ‡çš„é…å¯¹ï¼š

- æ·»åŠ  `NSAccessorySetupKitSupports`ï¼Œç±»åž‹ä¸º `Array`ï¼Œå¹¶å°† `Bluetooth` ä½œä¸ºç¬¬ä¸€ä¸ªé¡¹ç›®ã€‚
- æ·»åŠ  `NSAccessorySetupBluetoothServices`ï¼Œç±»åž‹ä¸º `Array`ï¼Œå¹¶å°†ä»¥ä¸‹ UUID ä½œä¸º `String` é¡¹ï¼š
  - `6E40FFF0-B5A3-F393-E0A9-E50E24DCCA9E`
  - `0000180A-0000-1000-8000-00805F9B34FB`

è‡³æ­¤ï¼Œåˆæ­¥é…ç½®å®Œæˆï¼ðŸ¤—


![](https://files.mdnice.com/user/38198/011bcddb-3c76-4b59-b94a-abf87488cf31.png)

### Ring Session Manager ç±»

æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ª `RingSessionManager` ç±»ï¼Œç”¨äºŽç®¡ç†æ‰€æœ‰ä¸Žæˆ’æŒ‡çš„é€šä¿¡ã€‚æ­¤ç±»çš„ä¸»è¦èŒè´£åŒ…æ‹¬ï¼š

- æ‰«æé™„è¿‘çš„æˆ’æŒ‡
- è¿žæŽ¥åˆ°æˆ’æŒ‡
- å‘çŽ°æœåŠ¡å’Œç‰¹å¾
- å®žçŽ°æ•°æ®è¯»å†™æ“ä½œ

#### ç¬¬ä¸€æ­¥ï¼šåˆ›å»º RingSessionManager

é¦–å…ˆåˆ›å»ºä¸€ä¸ªæ–°çš„ Swift æ–‡ä»¶ï¼ˆâŒ˜Nï¼‰ï¼Œå‘½åä¸º `RingSessionManager.swift`ã€‚ä»¥ä¸‹æ˜¯ç±»çš„å®šä¹‰ä»¥åŠéœ€è¦å®žçŽ°çš„å…³é”®å±žæ€§ï¼š

```swift
@Observable
class RingSessionManager: NSObject {
    // è¿½è¸ªè¿žæŽ¥çŠ¶æ€
    var peripheralConnected = false
    var pickerDismissed = true

    // å­˜å‚¨å½“å‰è¿žæŽ¥çš„æˆ’æŒ‡
    var currentRing: ASAccessory?
    private var session = ASAccessorySession()

    // æ ¸å¿ƒè“ç‰™å¯¹è±¡
    private var manager: CBCentralManager?
    private var peripheral: CBPeripheral?
}
```

#### ç¬¬äºŒæ­¥ï¼šå‘çŽ°æˆ’æŒ‡

æˆ’æŒ‡é€šè¿‡ç‰¹å®šçš„è“ç‰™æœåŠ¡ UUID è¿›è¡Œå¹¿æ’­ã€‚ä¸ºäº†æ‰¾åˆ°å®ƒï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ª `ASDiscoveryDescriptor` å¯¹è±¡ï¼ŒæŒ‡å®šå…¶è“ç‰™æœåŠ¡çš„ UUIDã€‚ä»¥ä¸‹ä»£ç å®Œæˆäº†è¿™ä¸€åŠŸèƒ½ï¼š

```swift
private static let ring: ASPickerDisplayItem = {
    let descriptor = ASDiscoveryDescriptor()
    descriptor.bluetoothServiceUUID = CBUUID(string: "6E40FFF0-B5A3-F393-E0A9-E50E24DCCA9E")
    return ASPickerDisplayItem(
        name: "COLMI R02 Ring",
        productImage: UIImage(named: "colmi")!,
        descriptor: descriptor
    )
}()
```

ç¡®ä¿å°†æˆ’æŒ‡å›¾ç‰‡æ·»åŠ åˆ°é¡¹ç›®èµ„æºç›®å½•ä¸­ï¼Œæˆ–è€…ç”¨åˆé€‚çš„å ä½ç¬¦æ›¿æ¢ `UIImage(named: "colmi")!`ã€‚

#### ç¬¬ä¸‰æ­¥ï¼šæ˜¾ç¤ºæˆ’æŒ‡é€‰æ‹©å™¨

ä¸ºäº†è®©ç”¨æˆ·é€‰æ‹©æˆ’æŒ‡ï¼Œæˆ‘ä»¬è°ƒç”¨ç³»ç»Ÿå†…ç½®çš„è®¾å¤‡é€‰æ‹©å™¨ç•Œé¢ï¼š

```swift
func presentPicker() {
    session.showPicker(for: [Self.ring]) { error in
        if let error {
            print("Failed to show picker: \(error.localizedDescription)")
        }
    }
}
```

#### ç¬¬å››æ­¥ï¼šå¤„ç†æˆ’æŒ‡é€‰æ‹©

å½“ç”¨æˆ·ä»Žé€‰æ‹©å™¨ä¸­é€‰å®šè®¾å¤‡åŽï¼Œåº”ç”¨éœ€è¦å¤„ç†è¿žæŽ¥å’Œç®¡ç†é€»è¾‘ã€‚ä»¥ä¸‹ä»£ç å®žçŽ°äº†äº‹ä»¶å¤„ç†ï¼š

```swift
private func handleSessionEvent(event: ASAccessoryEvent) {
    switch event.eventType {
    case .accessoryAdded:
        guard let ring = event.accessory else { return }
        saveRing(ring: ring)
    case .activated:
        // é‡æ–°è¿žæŽ¥å·²é…å¯¹æˆ’æŒ‡
        guard let ring = session.accessories.first else { return }
        saveRing(ring: ring)
    case .accessoryRemoved:
        currentRing = nil
        manager = nil
    }
}
```

#### ç¬¬äº”æ­¥ï¼šå»ºç«‹è¿žæŽ¥

å®Œæˆé€‰æ‹©æˆ’æŒ‡åŽï¼Œæˆ‘ä»¬éœ€è¦ä¸Žå…¶å»ºç«‹è“ç‰™è¿žæŽ¥ï¼š

```swift
func connect() {
    guard let manager, manager.state == .poweredOn, let peripheral else { return }
    let options: [String: Any] = [
        CBConnectPeripheralOptionNotifyOnConnectionKey: true,
        CBConnectPeripheralOptionNotifyOnDisconnectionKey: true,
        CBConnectPeripheralOptionStartDelayKey: 1
    ]
    manager.connect(peripheral, options: options)
}
```

#### ç¬¬å…­æ­¥ï¼šç†è§£å§”æ‰˜æ–¹æ³•

åœ¨ `RingSessionManager` ä¸­ï¼Œæˆ‘ä»¬å®žçŽ°äº†ä¸¤ä¸ªå…³é”®çš„å§”æ‰˜åè®®ï¼Œç”¨äºŽç®¡ç†è“ç‰™é€šä¿¡è¿‡ç¨‹ã€‚

**ä¸­å¤®ç®¡ç†å™¨å§”æ‰˜ï¼ˆCBCentralManagerDelegateï¼‰**  
æ­¤å§”æ‰˜ä¸»è¦å¤„ç†è“ç‰™è¿žæŽ¥çš„æ•´ä½“çŠ¶æ€ã€‚

```swift
func centralManagerDidUpdateState(_ central: CBCentralManager) {
    print("Central manager state: \(central.state)")
    switch central.state {
    case .poweredOn:
        if let peripheralUUID = currentRing?.bluetoothIdentifier {
            if let knownPeripheral = central.retrievePeripherals(withIdentifiers: [peripheralUUID]).first {
                print("Found previously connected peripheral")
                peripheral = knownPeripheral
                peripheral?.delegate = self
                connect()
            } else {
                print("Known peripheral not found, starting scan")
            }
        }
    default:
        peripheral = nil
    }
}
```

å½“è“ç‰™å¼€å¯æ—¶ï¼Œç¨‹åºä¼šæ£€æŸ¥æ˜¯å¦æœ‰å·²è¿žæŽ¥çš„æˆ’æŒ‡ï¼Œå¹¶å°è¯•é‡æ–°è¿žæŽ¥ã€‚  
æˆåŠŸè¿žæŽ¥åŽï¼š

```swift
func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {
    print("DEBUG: Connected to peripheral: \(peripheral)")
    peripheral.delegate = self
    print("DEBUG: Discovering services...")
    peripheral.discoverServices([CBUUID(string: Self.ringServiceUUID)])
    peripheralConnected = true
}
```

æ–­å¼€è¿žæŽ¥æ—¶ï¼š

```swift
func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: (any Error)?) {
    print("Disconnected from peripheral: \(peripheral)")
    peripheralConnected = false
    characteristicsDiscovered = false
}
```

**å¤–è®¾å§”æ‰˜ï¼ˆCBPeripheralDelegateï¼‰**  

æ­¤å§”æ‰˜ä¸»è¦å¤„ç†ä¸Žæˆ’æŒ‡çš„å…·ä½“é€šä¿¡ã€‚  
é¦–å…ˆå‘çŽ°æˆ’æŒ‡çš„æœåŠ¡ï¼š

```swift
func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: (any Error)?) {
    print("DEBUG: Services discovery callback, error: \(String(describing: error))")
    guard error == nil, let services = peripheral.services else {
        print("DEBUG: No services found or error occurred")
        return
    }
    print("DEBUG: Found \(services.count) services")
    for service in services {
        if service.uuid == CBUUID(string: Self.ringServiceUUID) {
            print("DEBUG: Found ring service, discovering characteristics...")
            peripheral.discoverCharacteristics([
                CBUUID(string: Self.uartRxCharacteristicUUID),
                CBUUID(string: Self.uartTxCharacteristicUUID)
            ], for: service)
        }
    }
}
```

å‘çŽ°ç‰¹å¾åŽï¼š

```swift
func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {
    print("DEBUG: Characteristics discovery callback, error: \(String(describing: error))")
    guard error == nil, let characteristics = service.characteristics else {
        print("DEBUG: No characteristics found or error occurred")
        return
    }
    print("DEBUG: Found \(characteristics.count) characteristics")
    for characteristic in characteristics {
        switch characteristic.uuid {
        case CBUUID(string: Self.uartRxCharacteristicUUID):
            print("DEBUG: Found UART RX characteristic")
            self.uartRxCharacteristic = characteristic
        case CBUUID(string: Self.uartTxCharacteristicUUID):
            print("DEBUG: Found UART TX characteristic")
            self.uartTxCharacteristic = characteristic
            peripheral.setNotifyValue(true, for: characteristic)
        default:
            print("DEBUG: Found other characteristic: \(characteristic.uuid)")
        }
    }
    characteristicsDiscovered = true
}
```

æŽ¥æ”¶æ•°æ®æ—¶ï¼š

```swift
func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
    if characteristic.uuid == CBUUID(string: Self.uartTxCharacteristicUUID) {
        if let value = characteristic.value {
            print("Received value: \(value)")
        }
    }
}
```

å‘é€å‘½ä»¤åŽï¼š

```swift
func peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) {
    if let error = error {
        print("Write to characteristic failed: \(error.localizedDescription)")
    } else {
        print("Write to characteristic successful")
    }
}
```


##### å®Œæ•´ä»£ç 

å®Œæ•´çš„ `RingSessionManager` ç±»ä»£ç å¦‚ä¸‹ï¼š

```swift
import Foundation
import AccessorySetupKit
import CoreBluetooth
import SwiftUI

@Observable
class RingSessionManager: NSObject {
    var peripheralConnected = false
    var pickerDismissed = true
    
    var currentRing: ASAccessory?
    private var session = ASAccessorySession()
    private var manager: CBCentralManager?
    private var peripheral: CBPeripheral?
    
    private var uartRxCharacteristic: CBCharacteristic?
    private var uartTxCharacteristic: CBCharacteristic?
    
    private static let ringServiceUUID = "6E40FFF0-B5A3-F393-E0A9-E50E24DCCA9E"
    private static let uartRxCharacteristicUUID = "6E400002-B5A3-F393-E0A9-E50E24DCCA9E"
    private static let uartTxCharacteristicUUID = "6E400003-B5A3-F393-E0A9-E50E24DCCA9E"
    
    private static let deviceInfoServiceUUID = "0000180A-0000-1000-8000-00805F9B34FB"
    private static let deviceHardwareUUID = "00002A27-0000-1000-8000-00805F9B34FB"
    private static let deviceFirmwareUUID = "00002A26-0000-1000-8000-00805F9B34FB"
    
    private static let ring: ASPickerDisplayItem = {
        let descriptor = ASDiscoveryDescriptor()
        descriptor.bluetoothServiceUUID = CBUUID(string: ringServiceUUID)
        
        return ASPickerDisplayItem(
            name: "COLMI R02 Ring",
            productImage: UIImage(named: "colmi")!,
            descriptor: descriptor
        )
    }()
    
    private var characteristicsDiscovered = false
    
    override init() {
        super.init()
        self.session.activate(on: DispatchQueue.main, eventHandler: handleSessionEvent(event:))
    }
    
    // MARK: - RingSessionManager actions
    func presentPicker() {
        session.showPicker(for: [Self.ring]) { error in
            if let error {
                print("Failed to show picker due to: \(error.localizedDescription)")
            }
        }
    }
    
    func removeRing() {
        guard let currentRing else { return }
        
        if peripheralConnected {
            disconnect()
        }
        
        session.removeAccessory(currentRing) { _ in
            self.currentRing = nil
            self.manager = nil
        }
    }
    
    func connect() {
        guard
            let manager, manager.state == .poweredOn,
            let peripheral
        else {
            return
        }
        let options: [String: Any] = [
            CBConnectPeripheralOptionNotifyOnConnectionKey: true,
            CBConnectPeripheralOptionNotifyOnDisconnectionKey: true,
            CBConnectPeripheralOptionStartDelayKey: 1
        ]
        manager.connect(peripheral, options: options)
    }
    
    func disconnect() {
        guard let peripheral, let manager else { return }
        manager.cancelPeripheralConnection(peripheral)
    }
    
    // MARK: - ASAccessorySession functions
    private func saveRing(ring: ASAccessory) {
        currentRing = ring
        
        if manager == nil {
            manager = CBCentralManager(delegate: self, queue: nil)
        }
    }
    
    private func handleSessionEvent(event: ASAccessoryEvent) {
        switch event.eventType {
        case .accessoryAdded, .accessoryChanged:
            guard let ring = event.accessory else { return }
            saveRing(ring: ring)
        case .activated:
            guard let ring = session.accessories.first else { return }
            saveRing(ring: ring)
        case .accessoryRemoved:
            self.currentRing = nil
            self.manager = nil
        case .pickerDidPresent:
            pickerDismissed = false
        case .pickerDidDismiss:
            pickerDismissed = true
        default:
            print("Received event type \(event.eventType)")
        }
    }
}

// MARK: - CBCentralManagerDelegate
extension RingSessionManager: CBCentralManagerDelegate {
    func centralManagerDidUpdateState(_ central: CBCentralManager) {
        print("Central manager state: \(central.state)")
        switch central.state {
        case .poweredOn:
            if let peripheralUUID = currentRing?.bluetoothIdentifier {
                if let knownPeripheral = central.retrievePeripherals(withIdentifiers: [peripheralUUID]).first {
                    print("Found previously connected peripheral")
                    peripheral = knownPeripheral
                    peripheral?.delegate = self
                    connect()
                } else {
                    print("Known peripheral not found, starting scan")
                }
            }
        default:
            peripheral = nil
        }
    }
    
    func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {
        print("DEBUG: Connected to peripheral: \(peripheral)")
        peripheral.delegate = self
        print("DEBUG: Discovering services...")
        peripheral.discoverServices([CBUUID(string: Self.ringServiceUUID)])
        
        peripheralConnected = true
    }
    
    func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: (any Error)?) {
        print("Disconnected from peripheral: \(peripheral)")
        peripheralConnected = false
        characteristicsDiscovered = false
    }
    
    func centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: (any Error)?) {
        print("Failed to connect to peripheral: \(peripheral), error: \(error.debugDescription)")
    }
}

// MARK: - CBPeripheralDelegate
extension RingSessionManager: CBPeripheralDelegate {
    func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: (any Error)?) {
        print("DEBUG: Services discovery callback, error: \(String(describing: error))")
        guard error == nil, let services = peripheral.services else {
            print("DEBUG: No services found or error occurred")
            return
        }
        
        print("DEBUG: Found \(services.count) services")
        for service in services {
            if service.uuid == CBUUID(string: Self.ringServiceUUID) {
                print("DEBUG: Found ring service, discovering characteristics...")
                peripheral.discoverCharacteristics([
                    CBUUID(string: Self.uartRxCharacteristicUUID),
                    CBUUID(string: Self.uartTxCharacteristicUUID)
                ], for: service)
            }
        }
    }
    
    func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {
        print("DEBUG: Characteristics discovery callback, error: \(String(describing: error))")
        guard error == nil, let characteristics = service.characteristics else {
            print("DEBUG: No characteristics found or error occurred")
            return
        }
        
        print("DEBUG: Found \(characteristics.count) characteristics")
        for characteristic in characteristics {
            switch characteristic.uuid {
            case CBUUID(string: Self.uartRxCharacteristicUUID):
                print("DEBUG: Found UART RX characteristic")
                self.uartRxCharacteristic = characteristic
            case CBUUID(string: Self.uartTxCharacteristicUUID):
                print("DEBUG: Found UART TX characteristic")
                self.uartTxCharacteristic = characteristic
                peripheral.setNotifyValue(true, for: characteristic)
            default:
                print("DEBUG: Found other characteristic: \(characteristic.uuid)")
            }
        }
        characteristicsDiscovered = true
    }
    
    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
        if characteristic.uuid == CBUUID(string: Self.uartTxCharacteristicUUID) {
            if let value = characteristic.value {
                print("Received value: \(value)")
            }
        }
    }
    
    func peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) {
        if let error = error {
            print("Write to characteristic failed: \(error.localizedDescription)")
        } else {
            print("Write to characteristic successful")
        }
    }
}

```

### æœ€åŽä¸€æ­¥ï¼šå°†å…¶åº”ç”¨åˆ°æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºä¸­

åœ¨ `ContentView.swift` ä¸­ç²˜è´´ä»¥ä¸‹ä»£ç ï¼Œä½œä¸ºä¸»ç•Œé¢çš„ä¸€éƒ¨åˆ†ï¼š

```swift
import SwiftUI
import AccessorySetupKit

struct ContentView: View {
    @State var ringSessionManager = RingSessionManager()
    var body: some View {
        List {
            Section("MY DEVICE", content: {
                if ringSessionManager.pickerDismissed, let currentRing = ringSessionManager.currentRing {
                    makeRingView(ring: currentRing)
                } else {
                    Button {
                        ringSessionManager.presentPicker()
                    } label: {
                        Text("Add Ring")
                            .frame(maxWidth: .infinity)
                            .font(Font.headline.weight(.semibold))
                    }
                }
            })
        }.listStyle(.insetGrouped)
    }
    
    @ViewBuilder
    private func makeRingView(ring: ASAccessory) -> some View {
        HStack {
            Image("colmi")
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(height: 70)
            VStack(alignment: .leading) {
                Text(ring.displayName)
                    .font(Font.headline.weight(.semibold))
            }
        }
    }
}

#Preview {
    ContentView()
}
```

å¦‚æžœä¸€åˆ‡é…ç½®æ­£ç¡®ï¼Œä½ çŽ°åœ¨å¯ä»¥æž„å»ºå¹¶è¿è¡Œåº”ç”¨ã€‚å½“ç‚¹å‡»â€œAdd Ringâ€æŒ‰é’®æ—¶ï¼Œå°†å¼¹å‡ºä¸€ä¸ªç•Œé¢ï¼Œæ˜¾ç¤ºé™„è¿‘çš„å…¼å®¹è®¾å¤‡ï¼ˆåŒ…æ‹¬ COLMI R02 æˆ’æŒ‡ï¼‰ã€‚é€‰æ‹©è®¾å¤‡åŽï¼Œåº”ç”¨å³å¯å®Œæˆè¿žæŽ¥ã€‚ðŸŽ‰

![](https://cdn-uploads.huggingface.co/production/uploads/66ba71a4447411b9c0e19d71/L7OYGOYxmfmrtbEagxyWu.png)


![è¿žæŽ¥æ¼”ç¤º](https://files.mdnice.com/user/38198/88ba809b-b14d-468a-8cf6-190e9db50b06.png)


åœ¨åŽç»­çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†è¿›ä¸€æ­¥æŽ¢ç´¢å¦‚ä½•ä¸Žæˆ’æŒ‡äº¤äº’ï¼ŒåŒ…æ‹¬è¯»å–ç”µæ± ç”µé‡ã€èŽ·å–ä¼ æ„Ÿå™¨æ•°æ®ï¼ˆå¦‚ PPG å’ŒåŠ é€Ÿåº¦è®¡ï¼‰ï¼Œå¹¶åŸºäºŽè¿™äº›æ•°æ®å¼€å‘å®žæ—¶å¿ƒçŽ‡ç›‘æµ‹ã€æ´»åŠ¨è¿½è¸ªåŠç¡çœ æ£€æµ‹åŠŸèƒ½ã€‚æ•¬è¯·æœŸå¾…ï¼

> è‹±æ–‡åŽŸæ–‡: [https://hf.co/blog/cyrilzakka/halo-introduction](https://huggingface.co/blog/cyrilzakka/halo-introduction)
>
> åŽŸæ–‡ä½œè€…: Cyril, ML Researcher, Health AI Lead @ Hugging Face
>
> è¯‘è€…: Lu Cheng, Hugging Face Fellow
